---
layout: post
title:  "Needlessly Reimplementing a ReadWrite Lock In Go Using Channels"
date:   2013-10-24 11:00:00
categories: go golang
---

I've been playing around with [Go](http://golang.org/) on and off for about the past six months,
and I've really come to like it. It has nice concise syntax, a decent and understandable type
system and a very full-featured standard library, among other things. But the thing that has
really impressed me about Go is its concurrency primitives.

For those who are unfamiliar with Go, it provides a few features that make writing highly 
concurrent programs a dream: **channels** and **goroutines**. Goroutines are more or less just
lightweight threads. If you have a function called `doSomething` and you want to run it in
a seperate thread, you simply call it with the `go` keyword in front of it, like so:

    go doSomething()

The Go runtime takes care of everything scheduling the `doSomething` function and passed none
of the hassle back to you. Super simple stuff.

The other half of the puzzle are channels. Channels are a way to pass messages between multiple
goroutines. When channels are created, they are given a specific type. Reading to or writing from
a channel is a blocking operation. That is, when a goroutine tries to write to a channel, it is
blocked until another goroutine reads from that same channel (or vice-versa). Reading and writing
to a channel is done with the `<-` operator. For example,

    // read from someChannel and store the result in someVariable
    someVariable := <- someChannel

    // write someVariable to someOtherChannel
    someOtherChannel <- someVariable

And, as a quick note for the uninitiated, the `:=` operator is an assignment operator that infers
its type. So in this case, the type of `someVariable` would be whatever type `someChannel` is
sending. Makes sense, right?

Anyway, these primitives can be combined to do some pretty cool stuff. Although the Go standard
library contains does contain locks in the [sync](http://golang.org/pkg/sync/) package, we can
build out our own locks using channels and goroutines.

And, as a note, at this point I'm going to skip talking about structs, methods and interfaces and assume that 
either you can follow along or you can catch yourself up with this easy to follow
[Go tutorial](http://tour.golang.org/).

Needlessly Reimplementing a Basic Lock
--------------------------------------

Let's start with a basic lock. I'm going to 

    package ChannelLock

    type lock struct {
      acquireChan chan uint8
      releaseChan chan uint8
    }

    func CreateLock(){

    }

    // manages requests to acquire/release the lock
    func (l *lock) watch() {

      for {

        // block on reading the acquire channel until
        // someone requests to acquire the lock
        <- l.acquireChan
    
        // block on reading the release channel until
        // the lock is release
        <- l.releaseChan
 
      }

    }

    func (l *lock) Acquire() {

      // perform a blocking write on the acquireChan
      l.acquireChan <- 0

    }

    func (l *lock) Release() {

      // perform a blocking write on the acquireChan
      l.releaseChan <- 0

    }
